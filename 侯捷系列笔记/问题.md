1. 为什么函数返回函数中的局部变量时，不能返回引用？

   因为局部变量在函数执行完就被销毁了。

2. 为什么有的运算符重载函数要写在类内部，有的要写在类外部？

   因为类内部默认会有隐含参数this指针，this指针如果在左侧，运算符左侧就只能是该类的对象。

3. 为什么malloc分配的内存有上下两个cookie记录大小，而不是一个？

4. 为什么i++要比++i慢？

   因为i++的执行步骤如下：

   	1. 记录原值
   	2. 执行++i操作
   	3. 返回改变后的值

5. 为什么迭代器prefix（前++）返回引用，而迭代器postfix（后++）不返回引用？

   因为为了模拟整数int 的做法，允许++++i（可以前++两次），但不允许 i++++。

   *但是为什么可以前++两次就得返回引用？*  

6. 为什么双向循环链表要有虚结点（不存放数据）？

   为了满足容器的前闭后开区间。最后一个元素的下一个位置end()指向虚结点，如果没有这个虚结点，那么end()就指向了第一个元素。

7. vector在中间插入元素，当空间不足时，拷贝安插点后的原内容是怎么做的？

   应该是拷贝完之后就放入x，如果是在尾端，直接放入x。

8. C++函数模板怎么实现的实参推导？

9. initializer_list<>如何知晓传进来的list的长度，从而初始化array？

10. c++内存管理中，class allocator分配一大块内存时，将一大块内存转换为class类型，会自动切割吗？

    ```cpp
    Screen* p = reinterpret_cast<Screen*>(new char[chunk]); //假如Screen的大小为8，chunk为80
    ```

