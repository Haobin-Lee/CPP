### 程序、进程、线程

#### 程序

磁盘上的一个文件，windows下扩展名为.exe的文件，linux下为ls -la 可以看到文件权限rwx(x指代执行权限)

#### 进程

运行起来的可执行程序

#### 线程

+ 主线程

​	每个进程都有一个主线程，这个主线程是唯一的

​	进程启动时，主线程随着进程默认启动

​	实际上运行程序时，进程的主线程来调用main函数中的代码来运行，main函数执行完，进程也就执行结束了，	因此主线程和进程的寿命一致。

+ 线程是用来执行代码的，理解成一条代码的执行道路。

+ 主线程是系统帮我们创建的，我们也可以创建其他的线程，走不同的道路，甚至去不同的地方。

+ 线程并不是越多越好，每个线程都要消耗独立的堆栈空间，线程的切换要保存很多中间状态，切换会耗费本该属于程序运行的时间。不建议超过200-300个，可以不断调整和优化。
+ 因为主线程是自启动的，因此进程中至少有一个线程 -- 主线程。

+ 多线程程序可以同时干多个事



#### 并发的实现方法

1. 多个进程，每个进程中有一个主线程。
2. 单独的进程中，创建多个线程，创建主线程之外的其他线程。

##### 多进程并发

进程间通信

+ 同一个电脑：管道，文件，消息队列，共享内存
+ 不同电脑：socket通信技术					

例如：账号服务器 发送消息到 游戏逻辑服务器，是服务器进程之间的通信

##### 多线程并发

单个进程，创建了多个线程

每个线程都有自己的运行路径，一个进程中的所有线程共享地址空间（共享内存）-- 全局变量、全局指针、全局引用 都可以在线程之间传递

共享内存的问题：数据一致性问题

如果可以使用多线程或者多进程，优先考虑多线程并发



##### 线程的优点

线程启动速度更快，更轻量级

系统资源开销更少，执行速度更快，比如共享内存这种通信方式比任何其他通信方式更快

##### 线程的缺点

使用有一定难度，小心处理**数据一致性**问题



##### 进程的优点

+ 操作系统在进程间提供的附加保护操作和更高级别的通信机制，意味着可以更容易编写安全(*safe*)的并发代码
+ —可以使用远程连接(可能需要联网)的方式，在不同的机器上运行独立的进程

##### 进程的缺点

+ 进程之间的通信通常不是设置复杂，就是速度慢，这是因为操作系统会在进程间提供了一定的保护措施，以避免一个进程去修改另一个进程的数据
+ 运行多个进程所需的固定开销：需要时间启动进程，操作系统需要内部资源来管理进程，等等。 

#### C++11新标准线程库

主线程从main()函数开始执行，那么我们创建的线程也要从一个函数开始执行，函数执行完毕，线程停止。

整个进程是否执行完毕的标志是：主线程是否执行完

一般情况下，主线程执行完，子线程还没执行完毕，子线程会被操作系统强行终止。

所以要保证子线程的运行状态，让主线程一直保持运行。



包含头文件

```cpp
#include <thread>   // a) 包含头文件
#include <iostream>

using namespace std;

void myprint()  // b) 自定义线程要从一个函数开始运行
{
    cout << "myprint线程开始执行" << endl;
    
    cout <<"myprint线程执行完毕" << endl;
    
}

int main()
{
    
    thread myobj(myprint);
    myobj.join();
    
    cout << "主线程执行完毕" <<endl;
    return 0;
}
```



### 线程管理

**启动线程** ： 构造`std::thread`对象 即启动线程，参数可以传入 函数名 或者 仿函数名，参数中的函数执行完毕，对应线程执行结束。

传入仿函数对象时，如果传入临时变量，编译器会将其解析为 mythread 函数

```cpp
std::thread my_thread(background_task()); 
```

避免这个问题有2中解决方案

```cpp
std::thread my_thread((background_task())); // 1 使用多组括号
std::threadmy_thread{background_task()}; // 2 使用新统一的初始化语法
```

